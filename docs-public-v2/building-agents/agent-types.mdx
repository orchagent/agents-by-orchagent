---
title: "Agent Types"
description: "Agents vs skills - active executors and passive knowledge"
---

# Agent Types

OrchAgent supports **agents** (active executors) and **skills** (passive knowledge).

## The Key Difference

- **Agents** do things - they take input, process it, and return output
- **Skills** inform agents - they're reusable knowledge/instructions that can be injected into agents

Think of it this way: a skill tells an agent HOW to do something, while an agent actually DOES it.

## Comparison

| | Prompt-based Agent | Code-based Agent | Skill |
|-|--------------|------------|-------|
| **What it is** | Active executor | Active executor | Passive knowledge |
| **What you provide** | Prompt + input/output schema | Python/JS code | SKILL.md file |
| **Publish time** | Minutes | Hours | Minutes |
| **Complexity** | Single LLM call | Any logic | Instructions only |
| **Forking** | Easy (edit prompt) | Harder (understand code) | Easy (edit markdown) |
| **Best for** | Extraction, summarization | Multi-step workflows, APIs | Coding standards, style guides, domain rules |

## Agents

Agents are active executors. They take input, do work, and return output. OrchAgent supports two agent types:

## Prompt-Based Agents

Prompt-based agents are the simplest way to create an agent. You provide:

1. A prompt template with variable placeholders
2. An input schema (what callers send)
3. An output schema (what the LLM returns)

OrchAgent handles the LLM call for you.

### Example

```json
{
  "name": "sentiment-analyzer",
  "type": "prompt",
  "version": "v1",
  "description": "Analyze sentiment of text",
  "supported_providers": ["openai", "anthropic"],
  "prompt_template": "Analyze the sentiment of the following text and return a JSON object with 'sentiment' (positive, negative, or neutral) and 'confidence' (0-1).\n\nText: {{text}}",
  "input_schema": {
    "type": "object",
    "properties": {
      "text": { "type": "string", "description": "Text to analyze" }
    },
    "required": ["text"]
  },
  "output_schema": {
    "type": "object",
    "properties": {
      "sentiment": { "type": "string", "enum": ["positive", "negative", "neutral"] },
      "confidence": { "type": "number", "minimum": 0, "maximum": 1 }
    },
    "required": ["sentiment", "confidence"]
  }
}
```

### Prompt Template Variables

Use `{{variable}}` syntax in your prompt template:

```
Summarize the following {{document_type}} in {{language}}:

{{content}}

Focus on: {{focus_areas}}
```

Variables are replaced with values from the input at runtime.

### When to Use Prompt-Based

- Single LLM call is sufficient
- No external API calls needed
- No complex logic or branching
- Want quick iteration on prompts

## Code-Based Agents

Code-based agents run your code on OrchAgent infrastructure. You have full control over:

- Multiple LLM calls
- External API integrations
- Complex business logic
- Data processing pipelines

### Example

Create a FastAPI application:

```python
# main.py
from fastapi import FastAPI, Request
from pydantic import BaseModel

app = FastAPI()

class AnalyzeInput(BaseModel):
    repo_url: str

class AnalyzeOutput(BaseModel):
    issues: list[str]
    risk_score: float

@app.get("/health")
def health():
    return {"status": "healthy", "version": "v1"}

@app.post("/analyze")
async def analyze(input: AnalyzeInput) -> AnalyzeOutput:
    # Your custom logic here
    # - Clone repo
    # - Scan files
    # - Call LLM for analysis
    # - Aggregate results
    return AnalyzeOutput(
        issues=["Found hardcoded API key in config.py"],
        risk_score=0.7
    )
```

### Required Endpoints

Every code-based agent must implement:

```http
GET /health
```

Response:

```json
{
  "status": "healthy",
  "version": "v1"
}
```

### When to Use Code-Based

- Multiple LLM calls needed
- External API integrations
- Complex data processing
- Conditional logic based on intermediate results
- Need to call other agents (orchestration)

## Directory Structure

### Prompt-Based Agent

```
my-prompt-agent/
├── orchagent.json      # Agent configuration
└── README.md           # Documentation (optional)
```

### Code-Based Agent

```
my-code-agent/
├── orchagent.json      # Agent configuration
├── main.py             # FastAPI application
├── requirements.txt    # Python dependencies
├── Dockerfile          # Container configuration (optional)
└── README.md           # Documentation (optional)
```

## LLM Provider Configuration

Agents specify which LLM providers they support:

```json
{
  "supported_providers": ["openai", "anthropic", "gemini"]
}
```

Use `"any"` if your agent works with any provider:

```json
{
  "supported_providers": ["any"]
}
```

### Fallback Configuration

For code-based agents, specify fallback LLMs:

```python
# In your code
llm_config = {
    "primary": "gemini-2.5-flash",
    "fallbacks": ["gpt-4o-mini", "claude-3-haiku"]
}
```

## Skills

Skills are passive knowledge - markdown files containing instructions, rules, or domain expertise that can be injected into agents.

### What Skills Are For

- **Coding standards** - React best practices, security rules, style guides
- **Domain knowledge** - Legal requirements, industry regulations, company policies
- **Writing rules** - Tone guidelines, formatting standards, brand voice
- **Decision frameworks** - How to evaluate options, prioritize tasks, handle edge cases

### SKILL.md Format

Skills use the industry-standard Agent Skills format (adopted by Anthropic, Google, Microsoft, OpenAI, Cursor):

```markdown
---
name: react-best-practices
description: React optimization patterns for performance-critical apps
license: MIT
metadata:
  author: yourname
  version: "1.0"
---

## Rules

- Use functional components over class components
- Memoize expensive computations with useMemo
- Avoid inline function definitions in JSX
- ...
```

### YAML Frontmatter Fields

| Field | Required | Description |
|-------|----------|-------------|
| `name` | Yes | Max 64 chars, lowercase, hyphens only |
| `description` | Yes | When to use this skill (max 1024 chars) |
| `license` | No | License name (e.g., MIT) |
| `metadata` | No | Author, version, and other info |

### Directory Structure

```
my-skill/
├── SKILL.md              # Required - YAML frontmatter + instructions
├── references/           # Optional - additional docs
└── assets/               # Optional - templates, examples
```

### Using Skills

Skills can be used in two ways:

**1. Run standalone** - The skill becomes a simple prompt agent:

```bash
npx orchagent run yourorg/react-best-practices
```

**2. Compose with agents** - Inject skill knowledge into an agent:

```bash
# Add skills to an agent call
orch call yourorg/code-reviewer --skills yourorg/react-best-practices

# Use only specific skills (ignore agent's defaults)
orch call yourorg/code-reviewer --skills-only yourorg/react-best-practices

# Ignore all skills
orch call yourorg/code-reviewer --no-skills
```

### When to Create a Skill vs an Agent

| Create a **Skill** when... | Create an **Agent** when... |
|---------------------------|----------------------------|
| You have knowledge to share | You have a task to automate |
| Content is reusable across contexts | Logic is specific to one workflow |
| No structured input/output needed | You need defined schemas |
| Instructions could help any agent | You need code execution |

## Next Steps

<CardGroup cols={2}>
  <Card title="Manifest Format" icon="file-code" href="/building-agents/manifest-format">
    Full orchagent.json schema
  </Card>
  <Card title="Publishing" icon="upload" href="/building-agents/publishing">
    Publish your agent or skill
  </Card>
  <Card title="Orchestration" icon="diagram-project" href="/building-agents/orchestration">
    Compose agents and skills
  </Card>
</CardGroup>
