---
title: "Publishing"
description: "How to publish your agent or skill to orchagent"
---

Publish your agent or skill to make it available on the platform.

## Prerequisites

1. orchagent account with API key
2. CLI installed and authenticated
3. For agents: `orchagent.json` manifest in your directory
4. For skills: `SKILL.md` file in your directory

## Quick Start

```bash
# Navigate to your agent directory
cd my-agent

# Publish your agent
orch publish
```

## Publishing Skills

Skills use a simpler format than agents. Create a `SKILL.md` file:

```markdown
---
name: react-best-practices
description: React optimization patterns for code review
license: MIT
metadata:
  author: yourname
---

## Rules

- Use functional components over class components
- Memoize expensive computations with useMemo
- ...
```

Then publish:

```bash
cd my-skill
orch publish
```

The CLI auto-detects `SKILL.md` and publishes as a skill. See [Agent Types](/building-agents/agent-types#skills) for the full SKILL.md format.

---

## Publishing Agents

### Step 1: Initialize Your Agent

Create a new agent project:

```bash
# Create an agent (default: direct LLM, on-demand)
orch init my-agent

# Create an agent for always-on deployment
orch init my-agent --run-mode always_on

# Create a skill
orch init my-skill --type skill

cd my-agent
```

This creates a directory with the basic structure: `orchagent.json`, `prompt.md`, and `schema.json`. The manifest uses `"type": "agent"` with canonical fields.

<Tip>
The execution engine is inferred from your manifest at publish time. Add `runtime.command` for code execution, `loop` for a managed LLM loop, or leave both out for a direct LLM call. See [Manifest Format](/building-agents/manifest-format#behavior-fields) for details.
</Tip>

### Step 2: Configure Your Manifest

Edit `orchagent.json` with your agent's configuration:

```json
{
  "name": "my-agent",
  "type": "agent",
  "description": "What my agent does",
  "supported_providers": ["openai", "anthropic"]
}
```

See [Manifest Format](/building-agents/manifest-format) for all options.

### Step 3: Test Locally

Before publishing, test your agent locally:

```bash
# For direct LLM agents
orch run . --input '{"text": "test input"}'

# For code runtime agents
orch run .
```

### Step 4: Publish

```bash
orch publish
```

### Step 5: Deploy as a Service (Optional)

For agents with `runtime.command` or `loop` config that need to run continuously (Discord bots, webhook listeners, background workers), deploy as an always-on service:

```bash
orch service deploy yourorg/my-agent \
  --secret API_TOKEN \
  --env LOG_LEVEL=info
```

See [Always-On Services](/using-agents/services) for full documentation.

## What Happens on Publish

The platform runs several checks:

1. **Manifest validation** - Verifies `orchagent.json` is valid
2. **Schema validation** - Validates input/output schemas
3. **Dependency check** - Verifies all dependencies exist (for orchestrators)
4. **Cycle detection** - Ensures no circular dependencies

For **managed loop** agents (with `loop` config), the platform also:

1. Stores your `prompt.md` as the agent's system prompt
2. Stores `custom_tools` and `loop.max_turns` from your manifest
3. On each call, spins up an E2B sandbox with an agent runner
4. The runner gives the LLM your prompt, built-in tools, and custom tools
5. The LLM iterates until it calls `submit_result` or hits `max_turns`

For **code runtime** agents (with `runtime.command`), the platform also:

1. Creates a ZIP bundle of your code
2. Stores the bundle securely
3. On each call, spins up an E2B sandbox
4. Runs your command with input via stdin
5. Returns stdout as the response

## Versioning

Versions are **automatically assigned** by the server each time you publish. The first publish creates `v1`, the next creates `v2`, and so on.

```
https://api.orchagent.io/yourorg/my-agent/v1/analyze
https://api.orchagent.io/yourorg/my-agent/v2/analyze
```

### How It Works

- **Every `orch publish` creates a new version** - v1, v2, v3, etc.
- **Authors cannot control version numbers** - this is intentional for simplicity
- **All versions remain accessible** - old versions stay available for 60 days after deprecation

### Running a Specific Version

Use the `@version` syntax to pin to a specific version:

```bash
# Run the latest version
orch run yourorg/my-agent

# Run a specific version
orch run yourorg/my-agent@v1
orch run yourorg/my-agent@v2
```

Callers should pin to specific versions for stability in production environments.

## Source Available vs Server Only

Agents have two distribution modes that control what non-owners can see and do:

| Mode | Prompt/code visible? | `orch run --local` | Badge |
|------|---------------------|------------|-------|
| **Source Available** (`--local-download`) | Yes | Yes | "Source Available" |
| **Server Only** (default) | No — redacted | No — cloud only (`orch run`) | "Server Only" |

**Server-only agents** (the default) redact the prompt, manifest, and skill files from public API responses. This protects your intellectual property while still letting users run the agent via `orch run` (cloud execution).

**Source-available agents** expose the full prompt and code. Users can inspect, run locally, and [fork](/using-agents/cli-commands#fork) into their own workspace. Use this for open/community agents where transparency builds trust.

## Code Bundling

For code runtime agents (those with `runtime.command`), the CLI automatically creates a ZIP bundle of your project.

### Auto-Detection

The CLI detects code runtime projects by looking for:
- Python files (`.py`) with `requirements.txt`
- JavaScript files (`.js`) with `package.json`

### Entrypoint Detection

The CLI looks for entrypoints in this order:

**Python:** `main.py`, `app.py`, `agent.py`, `run.py`, `__main__.py`

**JavaScript:** `main.js`, `index.js`, `agent.js`, `main.ts`, `index.ts`, `agent.ts`

Override in your manifest:

```json
{
  "entrypoint": "sandbox_main.py"
}
```

### Bundle Exclusions

These files/directories are automatically excluded:

**Python:**
- `**/__pycache__/`, `**/*.pyc`, `**/*.pyo`, `**/*.egg-info/`
- `venv/`, `.venv/`, `env/`, `.env`
- `dist/`, `build/`, `.eggs/`
- `pyproject.toml`, `setup.py`, `setup.cfg`
- `.mypy_cache/`, `.pytest_cache/`, `.ruff_cache/`

**Node.js:**
- `node_modules/`
- `package.json`, `package-lock.json`, `yarn.lock`, `bun.lockb`
- `tsconfig.json`

**Git & IDE:**
- `.git/`, `.gitignore`, `.gitattributes`
- `.idea/`, `.vscode/`, `.DS_Store`

**Documentation:**
- `README.md`, `CHANGELOG.md`, `LICENSE`
- `docs/`

**Docker & CI:**
- `Dockerfile`, `docker-compose.yml`, `.dockerignore`
- `.github/`, `.gitlab-ci.yml`, `.circleci/`

**Tests:**
- `tests/`, `test/`, `__tests__/`
- `*_test.py`, `test_*.py`, `*.test.js`, `*.spec.ts`
- `conftest.py`, `pytest.ini`, `coverage/`

**Other:**
- `orchagent.json` (read separately)
- `*.zip`, `bundle.zip`
- `scripts/`, `Makefile`

For custom exclusions, add a `bundle` section to your manifest:

```json
{
  "name": "my-agent",
  "bundle": {
    "exclude": ["data/", "*.log"],
    "include": ["important.dat"]
  }
}
```

### Size Limits

- Maximum bundle size: **50MB**
- Keep bundles small for faster cold starts

### Dry Run

Preview your bundle and canonical fields without publishing:

```bash
orch publish --dry-run
```

This shows:
- Files that will be included
- Total bundle size
- Detected entrypoint

## Web UI Upload

You can also upload code bundles through the web dashboard as an alternative to the CLI.

### Upload via Dashboard

1. Go to [orchagent Dashboard](https://orchagent.io/dashboard)
2. Navigate to **Agents** → **My Agents**
3. Click **Upload Bundle** on your agent card
4. Drag and drop your ZIP file or click to select

### Bundle Requirements

When uploading manually, ensure your ZIP contains:
- `orchagent.json` at the root
- Your entrypoint file (`main.py`, etc.)
- `requirements.txt` or `package.json` (if needed)

### Bundle Status

Agent cards show bundle status indicators:
- ✓ **Active** - Bundle uploaded and ready
- ⏳ **Processing** - Bundle being validated
- ✗ **Error** - Bundle validation failed (check logs)

## Service Keys

When you publish an agent that has dependencies, the platform issues a **service key**:

```json
{
  "agent": { "...": "agent fields" },
  "service_key": "sk_agent_...",
  "service_key_prefix": "sk_agent_..."
}
```

<Warning>
Store the service key securely. It's only shown once on registration. Your agent uses this key to call other agents.
</Warning>

Set it as an environment variable for your deployed agent:

```bash
export ORCHAGENT_SERVICE_KEY="sk_agent_..."
```

## Publish Options

| Flag | Description |
|------|-------------|
| `--dry-run` | Validate and preview bundle without publishing |
| `--entrypoint <file>` | Override entrypoint for tools |
| `--skills <list>` | Default skills (comma-separated, e.g., `org/skill@v1,org/other@v1`) |
| `--skills-locked` | Lock default skills (callers cannot override via flags) |
| `--local-download` | Allow users to download and run locally. Without this flag, agents default to server-only. |

## Distribution

By default, new agents are **server-only** — users run them via `orch run` on orchagent's cloud servers. This is the recommended default for most agents.

To allow users to download and run your agent locally with `orch run --local`:

```bash
# Publish with local download enabled
orch publish --local-download
```

<Note>
Agent owners can always download their own agents regardless of this setting.
</Note>

## Troubleshooting

### "Manifest validation failed"

Check your `orchagent.json` for:
- Valid JSON syntax
- Required fields present
- Correct field types

### "Dependency not found"

Verify all dependencies in your manifest exist:
- Check org/agent names are correct
- Ensure dependencies are published
- Verify version strings match

### "Bundle too large"

Tool bundles have a 50MB size limit. To reduce size:
- Check for large files that shouldn't be included
- Remove `node_modules/` or `venv/` directories
- Use `bundle.exclude` in your manifest to exclude files

### "Entrypoint not found"

The CLI auto-detects entrypoints: `main.py`, `app.py`, `agent.py`, `run.py` for Python; `main.js`, `index.js`, `agent.js` for JavaScript. If your entrypoint has a different name:

```json
{
  "entrypoint": "sandbox_main.py"
}
```

## CI/CD Integration

### GitHub Actions

```yaml
name: Publish Agent

on:
  push:
    branches: [main]

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install CLI
        run: npm install -g orchagent

      - name: Publish
        env:
          ORCHAGENT_API_KEY: ${{ secrets.ORCHAGENT_API_KEY }}
        run: orch publish
```

### Environment Variables

For CI/CD, use environment variables instead of config files:

| Variable | Description |
|----------|-------------|
| `ORCHAGENT_API_KEY` | Your API key |
| `ORCHAGENT_API_URL` | API URL (defaults to production) |

## Next Steps

<CardGroup cols={2}>
  <Card title="Orchestration" icon="diagram-project" href="/building-agents/orchestration">
    Build agents that call other agents
  </Card>
  <Card title="CLI Reference" icon="terminal" href="/using-agents/cli-commands">
    All CLI commands
  </Card>
  <Card title="Billing" icon="credit-card" href="/concepts/billing">
    Platform credits and usage
  </Card>
</CardGroup>
